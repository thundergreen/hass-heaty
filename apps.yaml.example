# Example apps.yaml configuration for Heaty.
# Simply copy this, paste it into your apps.yaml and adapt as needed.


# This is a minimal example configuration that does just basic things.
# If you want to have further control over your heatings, use open window
# detection, set temperature based on entity states etc., please see the
# full example below.
heaty_minimal:
  # Obligatory settings that tell appdaemon where to find the app.
  # You shouldn't need to change these two.
  module: heaty_app
  class: Heaty

  rooms:

    # Define such a block for each room you want to control.
    living:
      thermostats:
        climate.heating_living:
        climate.heating_living_2:
      schedule:
      # From Monday to Friday, set temperature to 20.5 °C at 7.45 AM,
      # and to 16 °C at 11.00 PM.
      - 1-5;  07:45 = 20.5;  23:00 = 16
      # On weekends, set temperature to 20.5 °C at 8.15 AM,
      # and to 16 °C at 11.30 PM.
      - 6,7;  8:15 = 20.5;  23:30 = 16

    kitchen:
      thermostats:
        climate.heating_kitchen:
      schedule:
      # ...


# Full configuration example
heaty_full:
  # Obligatory settings that tell appdaemon where to find the app.
  # You shouldn't need to change these two.
  module: heaty_app
  class: Heaty

  # An unique id that identifies this instance of Heaty.
  # This is just needed if you plan to run multiple Heaty instances
  # on a single Home Assistant instance.
  # If set, the id has to be passed with every heaty_* event you emit
  # for Heaty to be able to determine the instance the event is
  # intended for.
  # (optional, default: null)
  heaty_id: null

  # Enable debugging output
  # (optional, default: false)
  debug: false

  # This switch can be used to turn off all rooms (e.g. for vacation times).
  # You may use any switch that has the states "on" and "off".
  # (optional, default: none)
  master_switch: input_boolean.heating_master

  # Whether to automatically turn all schedule switches on together
  # with the master switch.
  # (optional, default: true)
  master_controls_schedule_switches: true

  # Temperature that should be set when heatings are turned off.
  # 4 °C is recommended to protect against frost-induced damage.
  # A value of "off" will set the thermostat's operation mode
  # to off explicitly.
  # (optional, default: off)
  off_temp: 4

  # You can build schedules that are based on the current state of some
  # entities. We call these entities schedule entities. A schedule entity
  # can be any entity in Home Assistant.
  # The entities your schedules are based on should be registered in this
  # config block so that Heaty can detect state changes of these entities
  # and re-schedule your heatings eventually.
  schedule_entities:
    input_boolean.some_input:
    input_slider.temp:

  # In the following config block, you may define settings that affect
  # all thermostats in your setup. These can be overwritten on a per
  # thermostat basis.
  thermostat_defaults:

    # Delta that is added to the temperature value sent to this
    # thermostat in order to correct potential inaccuracies of
    # the temperature sensor.
    # (optional, default: 0)
    delta: 0.5

    # The minimum temperature the thermostat supports.
    # If a lower temperature than this is going to be set, the operation
    # mode will be switched off instead of setting the temperature.
    # (optional, default: null, which means there is no limitation)
    min_temp: 8

    # Whether you'd not like to query initial temperature values from
    # the thermostat. It is recommended to leave this option disabled
    # in order for Heaty to notice manual temperature changes made at
    # the thermostat.
    # (optional, default: false)
    ignore_updates: false

    # These two settings can be used to tweak the names of the
    # operation modes.
    # (optional, default: Heat)
    opmode_heat: Heat
    # (optional, default: Off)
    opmode_off: Off

    # You might want to use an alternative service that receives
    # the operation mode value.
    # (optional, default: climate/set_operation_mode)
    opmode_service: climate/set_operation_mode
    # (optional, default: operation_mode)
    opmode_service_attr: operation_mode
    # Entity attribute that holds the current operation mode.
    # This is used to detect manual temperature adjustments and provide
    # correct temperature values on startup.
    # (optional, default: operation_mode)
    opmode_state_attr: operation_mode

    # You might want to use an alternative service that receives
    # the temperature value.
    # (optional, default: climate/set_temperature)
    temp_service: climate/set_temperature
    # (optional, default: temperature)
    temp_service_attr: temperature
    # Entity attribute that holds the current target temperature.
    # This is used to detect manual temperature adjustments and provide
    # correct temperature values on startup.
    # (optional, default: temperature)
    temp_state_attr: temperature

  # In the following config block, you may define settings that affect
  # all window sensors in your setup. These can be overwritten on a per
  # sensor basis.
  window_sensor_defaults:

    # Sensor state needs to stay constant for this number of seconds
    #  before the window open/closed detection kicks in.
    # (optional, default: 10)
    delay: 10

    # By default, a state of "on" means open and "off" means closed.
    # When this is set to True, "on" means closed and "off" means open.
    # (optional, default: false)
    inverted: false

  rooms:

    # Create such a block for every room you want to control.
    living:
      # An alternative friendly name to display in logs.
      # (optional)
      friendly_name: Living Room

      # If turned off, this switch disables the scheduled control
      # for this room.
      # You may use any switch that has the states "on" and "off".
      # (optional)
      schedule_switch: input_boolean.heating_schedule_living

      # This setting controls whether changes made locally at one thermostat
      # should automatically be replicated at the other ones in this
      # particular room.
      # (optional, default: true)
      replicate_changes: true

      # Set this value to a number of minutes and Heaty will automatically
      # re-schedule the temperature after a manual change has been made.
      # If you, for instance, change the target temperature at one of your
      # thermostats and this value is set to 120, Heaty will again apply
      # the schedule 2 hours after you made the change.
      # (optional, default: 0)
      reschedule_delay: 0

      # All thermostats of this room go here.
      thermostats:

        climate.living1
          # We could, for instance, overwrite the delta for this
          # particular thermostat.
          delta: 1.0

        climate.living_2:
          # ...

      # Window open/closed detection
      window_sensors:

        # Create a sensor item for each window sensor you want to consider
        # and overwrite default parameters if needed.
        # A window sensor may be any binary_sensor that changes states
        # between "on" and "off".
        binary_sensor.window_living:
          inverted: true

      # Schedule for this room.
      # If you don't want to have this room be controlled by a schedule,
      # simply omit the schedule or leave it empty.
      # (optional)
      schedule:

      # A schedule consists of a number of rules, each defining:
      # - a set of weekdays and
      # - a set of daytimes and corresponding temperature expressions.
      #
      # For each rule, timers are created that set the desired temperatures
      # at the specified times on all weekdays the rule is valid on.
      #
      # This means, you don't specify time ranges and assign
      # temperatures to them. You rather provide times at which
      # a temperature change should happen.
      #
      # The different parts of a rule have to be separated by semicolons.
      # Any whitespace contained in a rule is ignored.
      #
      # What is a temperature expression?
      # Well, that is a fairly powerful way of expressing a temperature
      # based on the state of entities, constants and a mathematical
      # expression that glues all the values together.
      # Actually, a temperature expression is evaluated as normal Python code.
      # There is an object available under the name "app" which represents
      # the appdaemon.appapi.AppDaemon object of Heaty. You could,
      # for instance, retrieve values of input sliders via the normal
      # appdaemon API.
      # The following variables are available inside time expressions:
      # - app: the appdaemon.appapi.AppDaemon object
      # - datetime: Python's datetime module
      # - now: a datetime containing the current date and time
      # - date: a shortcut for now.date()
      # - time: a shortcut for now.time()
      #
      # Let's look at some examples to make things clearer.

      # From Monday to Friday, set temperature to 20.5 °C at 7.45 AM,
      # and to 16 °C at 11.00 PM.
      - 1-5;  07:45 = 20.5;  23:00 = 16

      # On weekends, set temperature to 20.5 °C at 8.15 AM,
      # and to 16 °C at 11.30 PM.
      - 6-7;  8:15 = 20.5;  23:30 = 16

      # On Mondays and Thursdays, additionally set temperature to the
      # value of input_slider.temp at 6.00 PM.
      - 1,4; 18:00 = app.get_state("input_slider.temp")

      # Let's have it a bit warmer at Christmas Eve.
      # Here is another interesting thing you can do with time expressions.
      # If such an expression evaluates to None, it is treated as if it
      # doesn't exist at all. You can use this behaviour to create rules
      # that are only valid for a specific date range, for instance.
      - 1-7; 18:00 = 22 if date == datetime.date(2017, 12, 24) else None
      - 1-7; 23:59 = 20 if date == datetime.date(2017, 12, 24) else None
